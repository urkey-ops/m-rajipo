<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Satsang Diksha Audio Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Noto+Sans+Devanagari:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
        .container {
            max-width: 960px;
        }
        .shloka-text {
            font-family: 'Noto Sans Devanagari', sans-serif;
            line-height: 1.8;
        }
        .audio-player {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .loading-animation {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen py-10 px-4 sm:px-6 lg:px-8">
    <div class="container bg-white p-8 rounded-2xl shadow-xl space-y-8">
        <header class="text-center">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900 mb-2">Satsang Diksha</h1>
            <p class="text-md sm:text-lg text-gray-600">Shlokas 1-10</p>
        </header>

        <main class="space-y-6">
            <div id="shloka-container" class="bg-gray-50 p-6 rounded-xl border border-gray-200 min-h-[300px] flex flex-col justify-center items-center text-center transition-all duration-300">
                <p id="shloka-id" class="text-lg font-semibold text-blue-600 mb-2"></p>
                <p id="shloka-text" class="shloka-text text-xl sm:text-2xl text-gray-800 transition-opacity duration-500 opacity-0"></p>
                <div id="loading-spinner" class="loading-animation hidden"></div>
            </div>

            <div class="audio-player bg-gray-100 p-4 rounded-xl flex items-center justify-between mt-4">
                <button id="prev-btn" class="bg-blue-500 text-white p-3 rounded-full hover:bg-blue-600 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                </button>
                <button id="play-pause-btn" class="bg-blue-600 text-white p-4 rounded-full hover:bg-blue-700 transition-colors duration-200 transform scale-100 hover:scale-105">
                    <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4.004a1 1 0 001.555.832l3.445-2.002a1 1 0 000-1.664l-3.445-2.002z" clip-rule="evenodd" />
                    </svg>
                    <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 hidden" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                    </svg>
                </button>
                <button id="next-btn" class="bg-blue-500 text-white p-3 rounded-full hover:bg-blue-600 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </button>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Firestore and Firebase Auth setup
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

            if (Object.keys(firebaseConfig).length === 0) {
                console.warn("Firebase config not available. App will not function with Firebase.");
            }
            
            // Shloka data with updated text
            const shlokas = [
                {
                    id: 1,
                    text: `स्वामिनारायणः साक्षाद् अक्षरपुरुषोत्तमः। सर्वेभ्यः परमो ध्येयः परमात्मा स एव हि॥1॥`,
                },
                {
                    id: 2,
                    text: `देहस्यान्ते स वै प्राप्योऽन्यथाऽसाध्यश्च स ध्रुवम्। तं च प्राप्स्यति नित्यं योऽत्राश्रितोऽक्षरधाम्नि वै॥2॥`,
                },
                {
                    id: 3,
                    text: `तस्यैव शरणापन्नो यः स्यात् स सर्वथा सुखम्। प्राप्स्यत्यक्षयम् सौख्यं मोक्षं च ध्रुवमुत्तमम्॥3॥`,
                },
                {
                    id: 4,
                    text: `संसारं हि तरिष्यन्ति येऽमुं मोक्षं च यान्ति ये। ते सर्वेऽपि हि सत्सङ्गात् प्राप्नुवन्ति तदुत्तमम्॥4॥`,
                },
                {
                    id: 5,
                    text: `अतोऽक्षरब्रह्मणि येऽभ्युद्यतास्ते सर्वेऽपि हि। मोक्षमार्गं हि तं मोक्षं प्राप्नुवन्ति ततो ध्रुवम्॥5॥`,
                },
                {
                    id: 6,
                    text: `सत्सङ्गः स्थापितस्तस्माद् दिव्योऽयं परब्रह्मणा। स्वामिनारायणेनेहा साक्षादेवावतीर्य च॥6॥`,
                },
                {
                    id: 7,
                    text: `सत्सङ्गस्यास्य विज्ञानं मुमुक्षूणां भवेदिति। शास्त्रं सत्सङ्गदीक्षेति शुभाशयेन विरच्यते॥7॥`,
                },
                {
                    id: 8,
                    text: `सत्सङ्ग इति सत्यस्य सङ्गतिः सा हि षड्‌विधा। सत्यस्य परमात्मनः सत्यस्याक्षरधाम्नश्च॥8॥`,
                },
                {
                    id: 9,
                    text: `सत्यस्य परमात्मनः सत्यस्याक्षरधाम्नश्च। सत्यस्यात्मनश्चैव सत्यस्य सद‍्गुरोस्तथा॥9॥`,
                },
                {
                    id: 10,
                    text: `सत्यस्य सच‍्छास्त्रस्य सत्यस्य साधोस्तथा। सत्सङ्गस्य हि लक्षणम्॥10॥`,
                },
            ];

            let currentShlokaIndex = 0;
            const shlokaIdElem = document.getElementById('shloka-id');
            const shlokaTextElem = document.getElementById('shloka-text');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const loadingSpinner = document.getElementById('loading-spinner');

            let audio = null;
            let isPlaying = false;
            let currentAudioSource = null;

            // This function handles the TTS API call and audio playback.
            async function playShloka(index) {
                // Do not proceed if already playing the same shloka
                if (currentAudioSource && currentAudioSource.id === shlokas[index].id) {
                    return;
                }

                if (audio) {
                    audio.pause();
                    audio.currentTime = 0;
                    audio = null;
                }

                // Show loading spinner and hide text
                shlokaTextElem.style.opacity = '0';
                loadingSpinner.classList.remove('hidden');
                
                // Get the shloka text to send to the TTS API
                const shloka = shlokas[index];
                const textToSpeak = `Say in a formal, informative tone: Shloka ${shloka.id}: ${shloka.text}`;
                
                try {
                    // Start the API call to generate TTS audio
                    const payload = {
                        contents: [{
                            parts: [{ text: textToSpeak }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Charon" }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                    // Exponential backoff for API calls
                    let response;
                    for (let i = 0; i < 3; i++) { // Max 3 retries
                        try {
                            response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            if (response.status !== 429) break;
                            await new Promise(res => setTimeout(res, Math.pow(2, i) * 1000));
                        } catch (error) {
                            console.error("Fetch attempt failed:", error);
                            if (i === 2) throw error;
                            await new Promise(res => setTimeout(res, Math.pow(2, i) * 1000));
                        }
                    }

                    if (!response.ok) {
                        throw new Error(`API call failed with status: ${response.status}`);
                    }

                    const result = await response.json();
                    const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                    const mimeType = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.mimeType;

                    if (!audioData || !mimeType || !mimeType.startsWith("audio/L16")) {
                        throw new Error("Invalid audio data received from API.");
                    }

                    // Decode base64 and create a Blob with a WAV header
                    const pcmData = base64ToArrayBuffer(audioData);
                    const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10) || 16000;
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);

                    audio = new Audio(audioUrl);
                    currentAudioSource = shlokas[index];
                    audio.play();
                    isPlaying = true;
                    updatePlayerUI();

                    // Hide loading spinner and show text
                    shlokaIdElem.textContent = `Shloka ${shloka.id}`;
                    shlokaTextElem.textContent = shloka.text;
                    loadingSpinner.classList.add('hidden');
                    shlokaTextElem.style.opacity = '1';

                    // Automatically play next shloka after the current one finishes
                    audio.onended = () => {
                        currentShlokaIndex = (currentShlokaIndex + 1) % shlokas.length;
                        playShloka(currentShlokaIndex);
                    };

                } catch (error) {
                    console.error("Error generating or playing audio:", error);
                    shlokaTextElem.textContent = "Error loading audio. Please try again.";
                    shlokaTextElem.style.opacity = '1';
                    loadingSpinner.classList.add('hidden');
                    isPlaying = false;
                    updatePlayerUI();
                }
            }

            // Function to convert base64 to ArrayBuffer
            function base64ToArrayBuffer(base64) {
                const binary_string = window.atob(base64);
                const len = binary_string.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                return bytes.buffer;
            }

            // Function to convert PCM to WAV format
            function pcmToWav(pcm16, sampleRate) {
                const dataLength = pcm16.length * 2;
                const buffer = new ArrayBuffer(44 + dataLength);
                const view = new DataView(buffer);

                // RIFF identifier
                writeString(view, 0, 'RIFF');
                // file length
                view.setUint32(4, 36 + dataLength, true);
                // RIFF type
                writeString(view, 8, 'WAVE');
                // format chunk identifier
                writeString(view, 12, 'fmt ');
                // format chunk length
                view.setUint32(16, 16, true);
                // sample format (1 = PCM)
                view.setUint16(20, 1, true);
                // channel count
                view.setUint16(22, 1, true);
                // sample rate
                view.setUint32(24, sampleRate, true);
                // byte rate (sample rate * block align)
                view.setUint32(28, sampleRate * 2, true);
                // block align (channel count * bytes per sample)
                view.setUint16(32, 2, true);
                // bits per sample
                view.setUint16(34, 16, true);
                // data chunk identifier
                writeString(view, 36, 'data');
                // data chunk length
                view.setUint32(40, dataLength, true);

                // Write the PCM data
                for (let i = 0; i < pcm16.length; i++) {
                    view.setInt16(44 + i * 2, pcm16[i], true);
                }

                return new Blob([view], { type: 'audio/wav' });
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            
            // Function to update the play/pause UI
            function updatePlayerUI() {
                if (isPlaying) {
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                } else {
                    playIcon.classList.remove('hidden');
                    pauseIcon.classList.add('hidden');
                }
            }

            // Play/Pause button event listener
            playPauseBtn.addEventListener('click', () => {
                if (audio) {
                    if (isPlaying) {
                        audio.pause();
                    } else {
                        audio.play();
                    }
                    isPlaying = !isPlaying;
                    updatePlayerUI();
                } else {
                    // First time a user clicks play, start the first shloka
                    if (!isPlaying) {
                        playShloka(currentShlokaIndex);
                    }
                }
            });

            // Previous button event listener
            prevBtn.addEventListener('click', () => {
                currentShlokaIndex = (currentShlokaIndex - 1 + shlokas.length) % shlokas.length;
                playShloka(currentShlokaIndex);
            });

            // Next button event listener
            nextBtn.addEventListener('click', () => {
                currentShlokaIndex = (currentShlokaIndex + 1) % shlokas.length;
                playShloka(currentShlokaIndex);
            });

            // Display initial shloka on load
            shlokaIdElem.textContent = `Shloka ${shlokas[currentShlokaIndex].id}`;
            shlokaTextElem.textContent = shlokas[currentShlokaIndex].text;
            shlokaTextElem.style.opacity = '1';
        });
    </script>
</body>
</html>
